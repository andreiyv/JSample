import java.util.*;

/*
Что такое Map и для чего он нужен?
----------------------------------
Map - интерфейс, описывающий  классы, предназначенные для хранения пар объектов. Один из объектов пары должен быть уникальным  - называется "ключом" (key),
второй объект, необязательно уникальный, называется "значением" (value). Всю пару называют "записью" (entry).

Как определить уникальность ключа?
-----------------------------------
Вспомним предыдущий абзац. Уникальный - значит не равный другим ключам. Как определить "равность"?
По функции equals(), определяемой в классе Object, а потому доступной для всех объектов.
Про тонкости equals() и ее переопределения в другом посте, а пока для нас достаточно знать, что ключи в Map сравниваются по методу
equals(), и при попытке добавить в Map запись с не уникальным ключом предыдущая запись будет затерта новой.

Какие реализации Map вы знаете?
--------------------------------
HashMap, TreeMap, LinkedHashMap

Поговорим теперь конкретно о HashMap

Как HashMap устроен внутри?
-----------------------------
Внутри HashMap - это массив. Элементы массива в документации называются бакетами (buckets).
Будем следовать этому наименованию и мы. В бакете хранится первый элемент связанного списка.
Вообще связанные списки можно обсудить в другом посте, главное, что нужно знать, связанный список - это цепочка объектов, каждый из которых
имеет ссылку на следующий объект из цепочки. Имея первый элемент, можно по цепочке добраться до всех элементов списка. Таким образом, HashMap внутри - массив связанных списков. Элемент связанного списка - объект класса Entry, содержит ключ, значение и ссылку на следующий Entry.

Что происходит при добавлении записи?
--------------------------------------
Сначала вычисляется hashcode() ключа. Функция hashcode() определена в классе Object, так что даже если вы не переопределите ее в своем классе ключа, она все равно сработает. Выдаст адрес обьекта в памяти или еще какое-нибудь случайное число (int). Затем из двух значений - hashcode и размер массива - математически вычисляется индекс бакета, соответствующего hashcode. Главное, что нужно тут знать - соответствие между ключом и бакетом не хранится, оно вычисляется.
Далее, найдя нужный бакет, запись помещается в соответствующий связанный список.

А как искать элемент?
----------------------
Поиск производится по ключу (ключ для поиска). Опять же по hashcode() ключа находим нужный бакет. Нашли бакет - значит нашли нужный нам связанный список. Далее проходим по списку и сравниваем ключи элементов списка с нашим ключом для поиска. Сравнение производим по функции equals(). Вернула функция true - значит нашли.
И для чего все это нужно?
Для ускорения работы. В первую очередь ускорение поиска. Напомню, соответствие между hashcode ключа и бакетом не хранится, а вычисляется. Математические вычисления - это быстро. Далее, сравнивать объекты по equals() все же придется, но количество этих объектов ограничено.

А недостатки?
-------------
Во-первых, потребляемая память. Не все бакеты заполнены списками, на нулевые бакеты тоже тратится место. Во-вторых, при росте таблицы растет и количество элементов в связанных списках. Это замедляет работу. Для оптимизации приходится увеличивать объем массива и заново перераспределять записи по бакетам. Этот процесс называется "рехешинг" (rehashing)

*/

public class HashSetDemo {
    public static void main (String[] args) {
        HashSet<String> hs = new HashSet();

        hs.add("A");
        hs.add("B");
        hs.add("C");

        for (String str: hs) {
            System.out.println(str + "\n");
        }

    }
}
